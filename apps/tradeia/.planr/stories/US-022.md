# US-022: Generación automática de notificaciones de señales

**Como** usuario del sistema de trading automatizado,
**quiero** recibir notificaciones en tiempo real cuando se generen nuevas señales de trading
**para** poder tomar decisiones de inversión oportunas y no perder oportunidades de mercado

## Contexto
El sistema actualmente genera señales de trading a través de diferentes estrategias, pero los usuarios no reciben notificaciones automáticas cuando se crean nuevas señales. Esta funcionalidad permitirá mantener a los usuarios informados sobre las oportunidades de trading en tiempo real.

## Criterios de aceptación

### Funcionales
- [x] **Notificación automática**: Cada vez que se genera una nueva señal, se debe enviar una notificación al usuario
- [x] **Contenido completo**: La notificación debe incluir todos los datos relevantes de la señal (símbolo, dirección, precio de entrada, stops, timeframe, estrategia)
- [x] **Múltiples canales**: Soporte para notificaciones por email y push notifications en la aplicación móvil
- [x] **Configuración por usuario**: Los usuarios deben poder configurar qué tipos de señales quieren recibir (por estrategia, símbolo, timeframe)
- [x] **Historial de notificaciones**: Los usuarios deben poder ver el historial de notificaciones enviadas

### Técnicos
- [x] **Trigger de base de datos**: Implementar un trigger en Supabase que detecte nuevos registros en la tabla `signals`
- [x] **Procesamiento asíncrono**: Las notificaciones se deben enviar de forma asíncrona para no bloquear la generación de señales
- [x] **Rate limiting**: Evitar spam de notificaciones con límites de frecuencia por usuario
- [x] **Integración NotificationAPI**: Usar NotificationAPI para envío de emails y push notifications
- [x] **Fallback**: Si NotificationAPI falla, tener un sistema de respaldo (logs, queue de reintento)

### No funcionales
- [x] **Rendimiento**: Las notificaciones no deben afectar el rendimiento de la generación de señales (< 100ms delay)
- [x] **Confiabilidad**: Garantizar entrega de notificaciones críticas con sistema de reintentos
- [x] **Escalabilidad**: Soporte para miles de usuarios concurrentes
- [x] **Seguridad**: Las notificaciones solo se envían a usuarios autorizados

## Casos de uso

### Escenario principal
1. El sistema genera una nueva señal BUY para BTC/USDT en timeframe 4H
2. Se almacena en la base de datos
3. El trigger de Supabase dispara un evento
4. Se procesa la notificación de forma asíncrona
5. El usuario recibe notificación por email y push con detalles completos

### Casos edge
- **Señal duplicada**: No enviar notificaciones para señales idénticas generadas en corto tiempo
- **Usuario inactivo**: No enviar notificaciones a usuarios que no han iniciado sesión en 30 días
- **Configuración desactivada**: Respetar las preferencias de notificación del usuario
- **Error en NotificationAPI**: Reintentar envío o usar sistema alternativo

## Notas de implementación

### Arquitectura propuesta
```
Señal Generada → DB Trigger → Queue (Redis/Supabase) → Notification Service → NotificationAPI → Usuario
```

### Componentes a implementar

#### 1. Database Trigger
```sql
-- Trigger en tabla signals
CREATE OR REPLACE FUNCTION notify_new_signal()
RETURNS TRIGGER AS $$
BEGIN
  -- Enviar notificación a través de pg_notify
  PERFORM pg_notify('new_signal', row_to_json(NEW)::text);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER signal_notification_trigger
  AFTER INSERT ON signals
  FOR EACH ROW EXECUTE FUNCTION notify_new_signal();
```

#### 2. Notification Service
- Servicio asíncrono que escucha eventos de la base de datos
- Filtra usuarios según preferencias
- Formatea contenido de notificaciones
- Envía a NotificationAPI con reintentos

#### 3. User Preferences
```sql
-- Tabla de preferencias de notificación
CREATE TABLE user_notification_preferences (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id),
  email_notifications BOOLEAN DEFAULT true,
  push_notifications BOOLEAN DEFAULT true,
  strategies TEXT[] DEFAULT ARRAY['moderate', 'conservative'],
  symbols TEXT[] DEFAULT ARRAY['BTC/USDT', 'ETH/USDT'],
  timeframes TEXT[] DEFAULT ARRAY['1H', '4H', '1D'],
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

## Developer Notes

### [2025-09-15] Planificación de implementación

**Arquitectura del sistema:**
```
CRONJOB → GENERADOR SEÑALES → ALMACENAMIENTO BD → TRIGGER → NOTIFICATION SERVICE → NOTIFICATIONAPI → USUARIO
```

**Componentes a implementar:**

1. **Database Schema Updates**
   - Tabla `user_notification_preferences`
   - Trigger `notify_new_signal()`

2. **Backend Services**
   - `NotificationService` class
   - Queue processor para eventos de señales
   - Integration con NotificationAPI

3. **API Endpoints**
   - `POST /api/user/notification-preferences` - Actualizar preferencias
   - `GET /api/user/notification-preferences` - Obtener preferencias
   - `GET /api/user/notifications` - Historial de notificaciones

**Flujo de trabajo:**
1. Cronjob se ejecuta según programación
2. Genera señales para todos los pares/timeframes configurados
3. Almacena señales en BD con metadata completa
4. Trigger de Supabase dispara evento de notificación
5. NotificationService procesa evento de forma asíncrona
6. Filtra usuarios según preferencias
7. Envía notificaciones vía NotificationAPI
8. Registra envío para auditoría

**Consideraciones de rendimiento:**
- Procesamiento asíncrono de notificaciones
- Rate limiting por usuario (máximo 10 notificaciones/minuto)
- Compresión de datos históricos de notificaciones
- Cache de preferencias de usuario

**Consideraciones de seguridad:**
- Validación de permisos para actualizar preferencias
- Sanitización de datos en notificaciones
- Rate limiting para prevenir abuso

### [2025-09-21] Implementación completada

**Endpoints implementados:**
- `POST /api/signals/generate` - Genera y almacena señales en BD con notificaciones automáticas
- `POST /api/user/notification-preferences` - Actualizar preferencias de notificación
- `GET /api/user/notification-preferences` - Obtener preferencias de notificación
- `GET /api/user/notifications` - Historial de notificaciones enviadas
- `GET /api/notifications/listener` - Listener para eventos de base de datos
- `POST /api/notifications/listener` - Trigger manual para testing

**Características implementadas:**
- ✅ Base de datos completa: Tablas `signals`, `user_notification_preferences`, `notifications_history`
- ✅ Trigger PostgreSQL `notify_new_signal()` con `pg_notify` para eventos en tiempo real
- ✅ NotificationService con filtrado inteligente por preferencias de usuario
- ✅ Integración completa con NotificationAPI (emails y push notifications)
- ✅ Sistema de reintentos y fallback para errores de NotificationAPI
- ✅ Rate limiting configurable por usuario
- ✅ Procesamiento asíncrono para no bloquear generación de señales
- ✅ Historial completo de notificaciones con auditoría
- ✅ Configuración granular: por estrategia, símbolo y timeframe
- ✅ Validaciones de seguridad y sanitización de datos

**Validaciones implementadas:**
- Autenticación requerida para todos los endpoints
- Validación de formato de preferencias
- Rate limiting por usuario
- Sanitización de contenido de notificaciones

**Testing realizado:**
- ✅ Tests unitarios para NotificationService
- ✅ Tests de integración con NotificationAPI
- ✅ Tests de carga para rate limiting
- ✅ Tests end-to-end del flujo completo

**Próximos pasos recomendados:**
- Monitoreo de entregabilidad de notificaciones
- A/B testing de formatos de notificación
- Implementación de notificaciones push nativas
- Análisis de engagement con notificaciones